<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>招聘网站合集</title>
    <url>/archives/8686eeea.html</url>
    <content><![CDATA[<!-- build time:Sat Feb 29 2020 16:20:54 GMT+0800 (GMT+08:00) --><p>列举一些常用的招聘网站</p><ul><li><p>拉勾网 <a href="https://www.lagou.com/" target="_blank" rel="noopener external nofollow noreferrer">https://www.lagou.com/</a></p></li><li><p>前程无忧 <a href="https://www.51job.com/" target="_blank" rel="noopener external nofollow noreferrer">https://www.51job.com/</a></p></li><li><p>智联招聘 <a href="https://www.zhaopin.com/" target="_blank" rel="noopener external nofollow noreferrer">https://www.zhaopin.com/</a></p></li><li><p>汇博网 <a href="http://www.huibo.com/" target="_blank" rel="noopener external nofollow noreferrer">http://www.huibo.com/</a></p></li><li><p>Boss直聘 <a href="https://www.zhipin.com/" target="_blank" rel="noopener external nofollow noreferrer">https://www.zhipin.com/</a></p></li><li><p>猎聘网 <a href="https://www.liepin.com/" target="_blank" rel="noopener external nofollow noreferrer">https://www.liepin.com/</a></p></li><li><p>中华英才网 <a href="http://www.chinahr.com/" target="_blank" rel="noopener external nofollow noreferrer">http://www.chinahr.com/</a></p></li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>其它</category>
      </categories>
      <tags>
        <tag>招聘网站</tag>
      </tags>
  </entry>
  <entry>
    <title>Idea下SSM框架整合的注意事项</title>
    <url>/archives/698d0255.html</url>
    <content><![CDATA[<!-- build time:Sat Feb 29 2020 16:20:54 GMT+0800 (GMT+08:00) --><p>本人在Idea下整合SSM框架时遇到了一些问题，在这里记录下来。</p><h4 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h4><ul><li>JDK：1.7</li><li>开发工具：Idea</li><li>项目构建工具：Maven 3.6.2</li><li>Spring、SpringMVC版本：5.2.3.RELEASE</li><li>Mybatis版本：3.5.4</li></ul><a id="more"></a><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><h5 id="springmvc最少的依赖引入"><a href="#springmvc最少的依赖引入" class="headerlink" title="springmvc最少的依赖引入"></a>springmvc最少的依赖引入</h5><p>ssm框架需要手动引入的spring相关依赖只有spring-webmvc和spring-jdbc。Maven传递性依赖机制会自动引入spring-webmvc和spring-jdbc所需要的依赖。</p><img src="https://i.loli.net/2020/02/24/zDwRfbj2ExUeXSg.png" style="zoom:80%"><center>图1 spring-webmvc依赖关系图</center>![](https://i.loli.net/2020/02/24/fBt2Ly6Wqav1ISl.png)<center>图2 spring-jdbc依赖关系图</center>##### 使用@ResponseBody注解返回对象报错<p>默认情况下，使用@ResponseBody和@RestController返回的数据只能是String类型，其它类型返回时会出现异常。此时加入依赖jackson-databind即可实现Java对象和JSON的相互转换，SpringMVC会自动添加Jackson的转换器。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;jackson.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="静态资源无法访问"><a href="#静态资源无法访问" class="headerlink" title="静态资源无法访问"></a>静态资源无法访问</h5><p>SpringMVC的DisparcherSeverlet会拦截所有请求，像html、js、css等静态资源也会拦截，浏览器无法正常获得这些资源，报404错误。解决方法有3种，以放行html为例。</p><ol><li>defaultServlet</li></ol><p>使用tomcat服务器的默认servlet处理静态资源，web.xml下配置。此时html页面由tomcat服务器的默认servlet处理。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--web.xml下配置--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>default<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.html<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>mvc:resources</li></ol><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--spring-mvc.xml下配置--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">location</span>=<span class="string">"/static/**"</span> <span class="attr">mapping</span>=<span class="string">"/static/"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>location为静态资源存放的位置，mapping为映射后的路径。mapping路径可以指定成其它，如mapping=”/web/static/“。此时静态资源访问路径就变成了/web/static/，html引入的css、js、image路径为<code>/web/static/</code>+<code>/static/后面的真实路径名</code>，如<code>/web/static/css/index.css</code></p><ol start="3"><li>mvc:default-servlet-handler</li></ol><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--spring-mvc.xml下配置--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:default-servlet-handler</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>在 WEB 容器启动的时候会在上下文中定义一个 DefaultServletHttpRequestHandler，它会对DispatcherServlet的请求进行处理，如果该请求已经作了映射，那么会接着交给后台对应的处理程序，如果没有作映射，就交给 WEB 应用服务器默认的 Servlet 处理，从而找到对应的静态资源，只有再找不到资源时才会报错。</p><p><code>&lt;mvc:default-servlet-handler/&gt;</code>起作用的前提就是需要我们把静态资源放在webapp下，而非WEB-INF下，否则还是会无效。</p><h5 id="事务配置失效"><a href="#事务配置失效" class="headerlink" title="事务配置失效"></a>事务配置失效</h5><p>事务一般在service层处理，applicationContext.xml只处理Service、dao层，spring-mvc.xml只扫描Controller注解。</p><p>同时使用springmvc 和 spring， 那么项目中就会有两个容器。spring的是父容器，先进行初始化；springmvc是子容器， 后进行初始化。子容器可以访问父容器的bean，父容器不能访问子容器的bean。<br>springmvc后初始化，会重新创建service对象并重新注入，而springmvc再次创建service对象时不会读取spring的配置文件，因此也就无法知道service层是需要创建代理对象的，所以springmvc创建的service是普通的对象，而不是动态代理对象。</p><p>实际测试发现，spring-mvc.xml中配置<code>&lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot; /&gt;</code>后spring-mvc中的bean也可支持事务，由此看来spring-mvc.xml不能读取applicationContext.xml的<code>tx:annotation-driven</code>配置。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--applicationContext.xml--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--开启注解的扫描，希望处理service和dao，controller不需要Spring框架去处理--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.kai.ssm"</span> &gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置哪些注解不扫描--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:exclude-filter</span> <span class="attr">type</span>=<span class="string">"annotation"</span> <span class="attr">expression</span>=<span class="string">"org.springframework.stereotype.Controller"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--spring-mvc.xml--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--开启注解扫描，只扫描Controller注解--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.kai.ssm"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:exclude-filter</span> <span class="attr">type</span>=<span class="string">"annotation"</span> <span class="attr">expression</span>=<span class="string">"org.springframework.stereotype.Service"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><ul><li><h5 id="Spring框架模块依赖关系"><a href="#Spring框架模块依赖关系" class="headerlink" title="Spring框架模块依赖关系"></a><a href="https://juejin.im/post/5b90d0c86fb9a05d2778e2c1" target="_blank" rel="noopener external nofollow noreferrer">Spring框架模块依赖关系</a></h5></li><li><h5 id="SpringMVC访问静态页面"><a href="#SpringMVC访问静态页面" class="headerlink" title="SpringMVC访问静态页面"></a><a href="https://segmentfault.com/a/1190000011272520" target="_blank" rel="noopener external nofollow noreferrer">SpringMVC访问静态页面</a></h5></li><li><h5 id="Spring和Spring-MVC包扫描"><a href="#Spring和Spring-MVC包扫描" class="headerlink" title="Spring和Spring MVC包扫描"></a><a href="https://www.cnblogs.com/junzi2099/p/8042476.html" target="_blank" rel="noopener external nofollow noreferrer">Spring和Spring MVC包扫描</a></h5></li><li><h5 id="SpringMVC-context-include-filter-amp-context-exclude-filter-爬坑"><a href="#SpringMVC-context-include-filter-amp-context-exclude-filter-爬坑" class="headerlink" title="SpringMVC  context:include-filter&amp;context:exclude-filter 爬坑"></a><a href="https://segmentfault.com/a/1190000012972619" target="_blank" rel="noopener external nofollow noreferrer">SpringMVC <a href="context:include-filter" rel="external nofollow noreferrer">context:include-filter</a>&amp;<a href="context:exclude-filter" rel="external nofollow noreferrer">context:exclude-filter</a> 爬坑</a></h5></li></ul><h4 id="ssm框架整合代码"><a href="#ssm框架整合代码" class="headerlink" title="ssm框架整合代码"></a>ssm框架整合代码</h4><ul><li><a href="https://github.com/wukai95/ssm" target="_blank" rel="noopener external nofollow noreferrer">ssm框架整合代码</a></li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>程序员</category>
        <category>框架</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>SpringMVC</tag>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>常用工具合集</title>
    <url>/archives/bb7b8ecd.html</url>
    <content><![CDATA[<!-- build time:Sat Feb 29 2020 16:20:54 GMT+0800 (GMT+08:00) --><p>个人常用工具合集</p><h4 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h4><ol><li><a href="https://www.typora.net/" target="_blank" rel="noopener external nofollow noreferrer">Typora</a>：markdown编辑器</li><li><a href="https://zh.snipaste.com/" target="_blank" rel="noopener external nofollow noreferrer">Snipaste</a>：截图工具，支持贴图功能</li><li><a href="https://www.listary.com/" target="_blank" rel="noopener external nofollow noreferrer">Listary</a>：本地文件搜索，收费版+免费版</li><li><a href="https://www.internetdownloadmanager.com/download.html" target="_blank" rel="noopener external nofollow noreferrer">Internet Download Manager</a>：网络下载器，收费需破解</li><li><a href="http://qttabbar.wikidot.com/" target="_blank" rel="noopener external nofollow noreferrer">QTTabBar</a>：windows资源管理器增强，支持多标签。下载前请先阅读<a href="https://sspai.com/post/52521" target="_blank" rel="noopener external nofollow noreferrer">使用教程</a></li><li><a href="https://molunerfinn.com/PicGo/" target="_blank" rel="noopener external nofollow noreferrer">PicGO</a>：图床上传工具，上传图片之后自动会将图片链接复制到你的剪贴板里。默认支持微博图床、七牛图床、腾讯云COS、又拍云、GitHub、SM.MS、阿里云OSS、Imgur。方便不同图床的上传需求。2.0版本开始更可以自己开发插件实现其他图床的上传需求</li><li><a href="https://geekuninstaller.com/" target="_blank" rel="noopener external nofollow noreferrer">Greek Uninstaller</a>：软件卸载并扫描清除相关残留文件。绿色软件，解压即用。支持 Windows 商店 UWP 应用的卸载，查看软件注册表和安装目录等。</li></ol><a id="more"></a><h4 id="Chorme插件"><a href="#Chorme插件" class="headerlink" title="Chorme插件"></a>Chorme插件</h4><ol><li><p>谷歌访问助手：免费的谷歌服务代理插件，可以解决chrome扩展无法自动更新的问题，同时可以访问谷歌google搜索，gmail邮箱，google学术等谷歌服务。<a href="http://www.cnplugins.com/office/gugefangwenzhushou/" target="_blank" rel="noopener external nofollow noreferrer">谷歌访问助手下载安装图文教程</a></p><p><strong>安装谷歌访问助手后，以下插件均可通过访问<a href="https://chrome.google.com/webstore/category/extensions" target="_blank" rel="noopener external nofollow noreferrer">谷歌网上应用店</a>安装</strong></p></li><li><p>Adblock Plus：免费的浏览器广告拦截器</p></li><li><p>Tampermonkey：油猴，通过安装各类脚本对网站进行定制。油猴默认是没有安装任何脚本的，脚本下载渠道：<a href="https://greasyfork.org/zh-CN" target="_blank" rel="noopener external nofollow noreferrer">Greasy Fork</a></p></li><li><p>Fatkun：网络图片批量下载工具</p></li><li><p>JSON Formatter：json格式化插件，调试时格式化浏览器输出的json数据</p></li><li><p>Convertio：文件转换器，将您的文件转换成任意格式</p></li><li><p>简悦：一款能给浏览器开启阅读模式的扩展，一键进入无干扰的沉浸式阅读体验，让页面内容更干净纯粹，让阅读更舒适</p></li></ol><h4 id="Tampermonkey-油猴脚本"><a href="#Tampermonkey-油猴脚本" class="headerlink" title="Tampermonkey 油猴脚本"></a>Tampermonkey 油猴脚本</h4><ol><li>AC-baidu：美化百度、谷歌、必应等浏览器，<a href="https://greasyfork.org/zh-CN" target="_blank" rel="noopener external nofollow noreferrer">Greasy Fork</a>中下载。百度美化效果</li></ol><img src="https://i.loli.net/2020/02/23/JyQtBelu31rRbk6.png" alt="百度美化效果"><ol start="2"><li>组合型多功能脚本：全网VIP视频免费破解去广告、全网音乐直接下载、百度网盘直接下载、知乎视频下载等多合一版。<a href="https://greasyfork.org/zh-CN" target="_blank" rel="noopener external nofollow noreferrer">Greasy Fork</a>中下载，如图第一个</li></ol><p><img src="https://i.loli.net/2020/02/23/IgjdTZvKhXs8oVW.png" alt="组合型多功能脚本"></p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>常用工具</category>
      </categories>
  </entry>
  <entry>
    <title>平衡二叉树</title>
    <url>/archives/4263f441.html</url>
    <content><![CDATA[<!-- build time:Sat Feb 29 2020 16:20:54 GMT+0800 (GMT+08:00) --><p>要弄明白平衡二叉树，首先来聊一聊二叉树的相关定义</p><a id="more"></a><h3 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h3><p>二叉查找树，也称二叉搜索树，或二叉排序树。其定义也比较简单，要么是一颗空树，要么就是具有如下性质的二叉树：</p><p>（1）若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</p><p>（2）若任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</p><p>（3）任意节点的左、右子树也分别为二叉查找树；</p><p>（4）没有键值相等的节点。</p><img src="https://yanxuan.nosdn.127.net/6c58764a1936eb1962d0c8a81566352d.png" alt="tree(1).png" style="zoom:67%"><p>如上图所示，是不同形态的二叉查找树。二叉查找树是对要查找的数据进行生成树，左支的值小于右支的值。在查找的时候也是一样的思路，从根节点开始，比节点大进入右支，比节点小进入左支，直到查找到目标值。</p><p>二叉查找树的插入算法比较简单：空树，就首先生成根节点；不是空树就按照查找的算法，找到父节点，然后作为叶子节点插入，如果值已经存在就插入失败。</p><p>删除操作稍微复杂一点，有如下几种情况：</p><p>（1）如果删除的是叶节点，可以直接删除；</p><p>（2）如果被删除的元素有一个子节点，可以将子节点直接移到被删除元素的位置；</p><p>（3）如果有两个子节点，这时候就采用中序遍历，找到待删除的节点的后继节点，将其与待删除的节点互换，此时待删除节点的位置已经是叶子节点，可以直接删除。如下图：</p><img src="https://yanxuan.nosdn.127.net/7d812594e539b9d72a9078cba2f9c5c5.png" alt="tree(2).png" style="zoom:67%"><p>将待删除节点与后继节点互换，变成如下图所示：</p><img src="https://yanxuan.nosdn.127.net/a31885f479ee1cbd3365c28d25ed3a28.png" alt="tree(3).png" style="zoom:67%"><p>将待删除元素删除，如下图所示：</p><img src="https://yanxuan.nosdn.127.net/042ef0261553c9132c4066d065bee65a.png" alt="tree(4).png" style="zoom:67%"><p>另外，二叉查找树还有一个性质，即对二叉查找树进行中序遍历，即可得到有序的数列。</p><p>二叉查找树的查询复杂度，和二分查找一样，插入和查找的时间复杂度均为O(logn)，但是在最坏的情况下仍然会有O(n)的时间复杂度。原因在于插入和删除元素的时候，树没有保持平衡（如上不同形态的二叉树图中的b）。</p><h3 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h3><p>平衡二叉搜索树，又被称为AVL树，且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。</p><p>由于普通的二叉查找树会容易失去”平衡“，极端情况下，二叉查找树会退化成线性的链表，导致插入和查找的复杂度下降到O(n)，所以，这也是平衡二叉树设计的初衷。那么平衡二叉树如何保持”平衡“呢？根据定义，有两个重点，一是左右两子树的高度差的绝对值不能超过1，二是左右两子树也是一颗平衡二叉树。</p><p>如下图所示，左图是一棵平衡二叉树，根节点10，左右两子树的高度差是1，而右图，虽然根节点左右两子树高度差是0，但是右子树15的左右子树高度差为2，不符合定义，所以右图不是一棵平衡二叉树。</p><img src="https://yanxuan.nosdn.127.net/974729e9c84fb2780b058f35eb0ad205.png" alt="tree(5).png" style="zoom:67%"><p>由此可以看出平衡二叉树是一棵高度平衡的二叉查找树。所以，要构建跟维系一棵平衡二叉树就比普通的二叉树要复杂的多。在构建一棵平衡二叉树的过程中，当有新的节点要插入时，检查是否因插入后而破坏了树的平衡。若出现不平衡，则要根据新插入的结点与最低不平衡结点的位置关系进行相应的调整。分为LL型、RR型、LR型和RL型4种类型，各调整方法如下(下面用A表示最低不平衡结点)：</p><h4 id="LL型调整"><a href="#LL型调整" class="headerlink" title="LL型调整"></a>LL型调整</h4><p>由于在A的左孩子(L)的左子树(L)上插入新结点，使原来平衡二叉树变得不平衡，此时A的平衡因子由1增至2。下面图1是LL型的最简单形式。显然，按照大小关系，结点B应作为新的根结点，其余两个节点分别作为左右孩子节点才能平衡，A结点就好像是绕结点B顺时针旋转一样。</p><img src="https://yanxuan.nosdn.127.net/9368b632ae3544e534ecea9be937b843.png" alt="tree(6).png" style="zoom:67%"><center>图1最简单的LL型调整</center>LL型调整的一般形式如下图2所示，表示在A的左孩子B的左子树BL(不一定为空)中插入结点(图中阴影部分所示)而导致不平衡(h表示子树的深度)。这种情况调整如下：①将A的左孩子B提升为新的根结点；②将原来的根结点A降为B的右孩子；③各子树按大小关系连接(BL和AR不变，BR调整为A的左子树)。 <img src="https://yanxuan.nosdn.127.net/78be4b17ef26785a4155cd70cc69b859.png" alt="tree(7).png" style="zoom:67%"><center>图2一般形式的LL型调整</center><h4 id="RR型调整"><a href="#RR型调整" class="headerlink" title="RR型调整"></a>RR型调整</h4><p>由于在A的右孩子(R)的右子树(R)上插入新结点，使原来平衡二叉树变得不平衡，此时A的平衡因子由-1变为-2。图3是RR型的最简单形式。显然，按照大小关系，结点B应作为新的根结点，其余两个节点分别作为左右孩子节点才能平衡，A结点就好像是绕结点B逆时针旋转一样。</p><img src="https://yanxuan.nosdn.127.net/edc502badeae3f40213386304d9175e3.png" alt="tree(8).png" style="zoom:67%"><center>图3最简单的RR型调整</center>RR型调整的一般形式如下图4所示，表示在A的右孩子B的右子树BR(不一定为空)中插入结点(图中阴影部分所示)而导致不平衡(h表示子树的深度)。这种情况调整如下：①将A的右孩子B提升为新的根结点；②将原来的根结点A降为B的左孩子；③各子树按大小关系连接(AL和BR不变，BL调整为A的右子树)。 <img src="https://yanxuan.nosdn.127.net/d8a7a775ecc85001bd22384b9bb5e46c.png" alt="tree(9).png" style="zoom:67%"><center>图4一般形式的RR型调整</center><h4 id="LR型调整"><a href="#LR型调整" class="headerlink" title="LR型调整"></a>LR型调整</h4><p>由于在A的左孩子(L)的右子树(R)上插入新结点，使原来平衡二叉树变得不平衡，此时A的平衡因子由1变为2。图5是LR型的最简单形式。显然，按照大小关系，结点C应作为新的根结点，其余两个节点分别作为左右孩子节点才能平衡。</p><img src="https://yanxuan.nosdn.127.net/bb1c05ca5fdf062ff3a8fa2903777969.png" alt="tree(10).png" style="zoom:67%"><center>图5最简单的LR型调整</center>LR型调整的一般形式如下图6所示，表示在A的左孩子B的右子树(根结点为C，不一定为空)中插入结点(图中两个阴影部分之一)而导致不平衡(h表示子树的深度)。这种情况调整如下：①将C的右孩子B提升为新的根结点；②将原来的根结点A降为C的右孩子；③各子树按大小关系连接(BL和AR不变，CL和CR分别调整为B的右子树和A的左子树)。 <img src="https://yanxuan.nosdn.127.net/bfd56d8977ca1b32f51eef4465107c85.png" alt="tree(11).png" style="zoom:67%"><center>图6一般形式的LR型调整</center><h4 id="RL型调整"><a href="#RL型调整" class="headerlink" title="RL型调整"></a>RL型调整</h4><p>由于在A的右孩子(R)的左子树(L)上插入新结点，使原来平衡二叉树变得不平衡，此时A的平衡因子由-1变为-2。图7是RL型的最简单形式。显然，按照大小关系，结点C应作为新的根结点，其余两个节点分别作为左右孩子节点才能平衡。</p><img src="https://yanxuan.nosdn.127.net/ff3cca62ae7634ab875a69d5f5138f7d.png" alt="tree(12).png" style="zoom:67%"><center>图7最简单的RL型调整</center>RL型调整的一般形式如下图8所示，表示在A的右孩子B的左子树(根结点为C，不一定为空)中插入结点(图中两个阴影部分之一)而导致不平衡(h表示子树的深度)。这种情况调整如下：①将C的右孩子B提升为新的根结点；②将原来的根结点A降为C的左孩子；③各子树按大小关系连接(AL和BR不变，CL和CR分别调整为A的右子树和B的左子树)。 <img src="https://yanxuan.nosdn.127.net/673eeb80fb0df899a741b29ad04f9639.png" alt="tree(13).png" style="zoom:67%"><center>图8一般形式的RL型调整</center>平衡二叉树构建的过程，就是节点插入的过程，插入失衡情况就上面4种。下面讲下平衡二叉树节点的删除，删除的情况会复杂一点，复杂的原因主要在于删除了节点之后要维系二叉树的平衡，但是删除二叉树节点总结起来就两个判断：①删除的是什么类型的节点？②删除了节点之后是否导致失衡？<p>节点的类型有三种：1.叶子节点；2.只有左子树或只有右子树；3.既有左子树又有右子树。</p><p>针对这三种节点类型，再引入判断②，所以处理思路分别是：</p><p>（1）当删除的节点是叶子节点，则将节点删除，然后从父节点开始，判断是否失衡，如果没有失衡，则再判断父节点的父节点是否失衡，直到根节点，此时到根节点还发现没有失衡，则说此时树是平衡的；如果中间过程发现失衡，则判断属于哪种类型的失衡（左左，左右，右左，右右），然后进行调整。</p><p>（2）删除的节点只有左子树或只有右子树，这种情况其实就比删除叶子节点的步骤多一步，就是将节点删除，然后把仅有一支的左子树或右子树替代原有结点的位置，后面的步骤就一样了，从父节点开始，判断是否失衡，如果没有失衡，则再判断父节点的父节点是否失衡，直到根节点，如果中间过程发现失衡，则根据失衡的类型进行调整。</p><p>（3）删除的节点既有左子树又有右子树，这种情况又比上面这种多一步，就是中序遍历，找到待删除节点的前驱或者后驱都行，然后与待删除节点互换位置，然后把待删除的节点删掉，后面的步骤也是一样，判断是否失衡，然后根据失衡类型进行调整。</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>程序员</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>hash算法</title>
    <url>/archives/f607c896.html</url>
    <content><![CDATA[<!-- build time:Sat Feb 29 2020 16:20:54 GMT+0800 (GMT+08:00) --><p>Hash也称散列、哈希，对应的英文都是Hash。基本原理就是把任意长度的输入，通过Hash算法变成固定长度的输出。这个映射的规则就是对应的Hash算法，而原始数据映射后的二进制串就是哈希值。</p><h3 id="Hash算法的特性"><a href="#Hash算法的特性" class="headerlink" title="Hash算法的特性"></a>Hash算法的特性</h3><p>正向快速：给定原始数据和 hash 算法，在有限时间和有限资源内能计算出 hash 值。</p><p>逆向困难：给定（若干） hash 值，在有限时间内很难（基本不可能）逆推出原始数据。</p><p>输入敏感：原始输入信息修改一点信息，产生的 hash 值看起来应该都有很大不同。</p><p>冲突避免：很难找到两段内容不同的原始数据，使得它们的 hash 值一致（发生冲突）。即对于任意两个不同的数据块，其hash值相同的可能性极小；对于一个给定的数据块，找到和它hash值相同的数据块极为困难。</p><a id="more"></a><h3 id="Hash算法的简单实现"><a href="#Hash算法的简单实现" class="headerlink" title="Hash算法的简单实现"></a>Hash算法的简单实现</h3><p>求模算法作为一种不可逆的计算方法，已经成为了整个现代密码学的根基。只要是涉及到计算机安全和加密的领域，都会有模计算的身影。Hash算法也并不例外，一种最原始的Hash算法就是单纯地选择一个数进行模运算。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="comment">// p一般取素数</span></span><br><span class="line">    <span class="keyword">return</span> key % p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述的程序完成了一个散列算法所应当实现的初级目标：用较少的文本量代表很长的内容（求模之后的数字肯定小于p），常应用于数据结构中。但对于安全领域，单纯使用求模算法计算之后的结果带有明显的规律性，这种规律将导致算法将能难保证不可逆性。所以我们将使用另外一种手段，那就是异或。</p><p>再来看下面一段程序，我们在散列函数中加入一个异或过程。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> key % p ^ <span class="number">5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显的，加入一层异或过程之后，计算之后的结果规律性就不是那么明显了。当然，大家也许会觉得这样的算法依旧很不安全，如果用户使用连续变化的一系列文本与计算结果相比对，就很有可能找到算法所包含的规律。但是我们还有其他的办法。比如在进行计算之前对原始文本进行修改，或是加入额外的运算过程（如移位），比如以下程序。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (key + <span class="number">2</span> + (key &lt;&lt; <span class="number">1</span>)) % p ^ <span class="number">5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样处理得到的散列算法就很难发现其内部规律，也就是说，我们并不能很轻易地给出一个数，让它经过上述散列函数运算之后的结果等于4——除非我们去穷举测试。</p><h3 id="Hash算法处理碰撞"><a href="#Hash算法处理碰撞" class="headerlink" title="Hash算法处理碰撞"></a>Hash算法处理碰撞</h3><p>由于hash的原理是将输入空间的值映射成hash空间内，而hash值的空间远小于输入的空间。因此一定会存在不同的输入被映射成相同输出的情况。那么作为一个好的hash算法，就需要这种冲突的概率尽可能小。</p><p>比较常用的算法是链地址法和开放地址法。</p><h4 id="链地址法"><a href="#链地址法" class="headerlink" title="链地址法"></a>链地址法</h4><p>链表地址法是使用一个链表数组，来存储相应数据，当hash遇到冲突的时候依次添加到链表的后面进行处理。</p><img src="https://gitee.com/big_yellow_duck/images/raw/master/typora/20200222141317-701491.jpeg" style="zoom:67%"><p>链地址在处理的流程如下：添加一个元素的时候，首先计算元素key的hash值，确定插入数组中的位置。如果当前位置下没有重复数据，则直接添加到当前位置。当遇到冲突的时候，添加到同一个hash值的元素后面，行成一个链表。这个链表的特点是同一个链表上的Hash值相同。java的数据结构HashMap使用的就是这种方法来处理冲突，JDK1.8中，针对链表上的数据超过8条的时候，使用了红黑树进行优化。</p><h4 id="开放地址法"><a href="#开放地址法" class="headerlink" title="开放地址法"></a>开放地址法</h4><p>开放地址法是指大小为 M 的数组保存 N 个键值对，其中 M &gt; N。我们需要依靠数组中的空位解决碰撞冲突。基于这种策略的所有方法被统称为“开放地址”哈希表。线性探测法，就是比较常用的一种“开放地址”哈希表的一种实现方式。线性探测法的核心思想是当冲突发生时，顺序查看表中下一单元，直到找出一个空单元或查遍全表。简单来说就是：一旦发生冲突，就去寻找下 一个空的散列表地址，只要散列表足够大，空的散列地址总能找到。</p><p>线性探测法的数学描述是：h(k, i) = (h(k, 0) + i) mod m，i表示当前进行的是第几轮探查。i=1时，即是探查h(k, 0)的下一个；i=2，即是再下一个。这个方法是简单地向下探查。mod m表示：到达了表的底下之后，回到顶端从头开始。对于开放寻址冲突解决方法，除了线性探测方法之外，还有另外两种比较经典的探测方法，二次探测（Quadratic probing）和双重散列（Double hashing）。但是不管采用哪种探测方法，当散列表中空闲位置不多的时候，散列冲突的概率就会大大提高。为了尽可能保证散列表的操作效率，一般情况下，我们会尽可能保证散列表中有一定比例的空闲槽位。我们用装载因子（load factor）来表示空位的多少。散列表的装载因子=填入表中的元素个数/散列表的长度。装载因子越大，说明冲突越多，性能越差。</p><h3 id="Hash算法的应用"><a href="#Hash算法的应用" class="headerlink" title="Hash算法的应用"></a>Hash算法的应用</h3><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><p>hash进行管理的数据结构中，就对速度比较重视，对抗碰撞不太看中，只要保证hash均匀分布就可以。比如hashmap，hash值（key）存在的目的是加速键值对的查找，key的作用是为了将元素适当地放在各个桶里，对于抗碰撞的要求没有那么高。换句话说，hash出来的key，只要保证value大致均匀的放在不同的桶里就可以了。但整个算法的set性能，直接与hash值产生的速度有关，所以这时候的hash值的产生速度就尤为重要。</p><p>在hashmap中，当put进一个键值对时，首先调用对象的hashCode()方法算出key的哈希值。这里以JDK中的String.hashCode()方法为例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> h = hash;</span><br><span class="line">   <span class="comment">//hash default value : 0 </span></span><br><span class="line">   <span class="keyword">if</span> (h == <span class="number">0</span> &amp;&amp; value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">     <span class="comment">//value : char storage</span></span><br><span class="line">     <span class="keyword">char</span> val[] = value;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; value.length; i++) &#123;</span><br><span class="line">       h = <span class="number">31</span> * h + val[i];</span><br><span class="line">     &#125;</span><br><span class="line">     hash = h;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很简洁的一个乘加迭代运算，在不少的hash算法中，使用的是异或+加法进行迭代，速度和前者差不多。接着将key的哈希值(int型32位)无符号右移16位，即取它的高16位返回,右移后高16位变成0，原高16位移动到低16位。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">  return putVal(hash(key), key, value, false, true);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static final int hash(Object key) &#123;</span><br><span class="line">  int h;</span><br><span class="line">  return (key &#x3D;&#x3D; null) ? 0 : (h &#x3D; key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来看具体的插入putVal方法:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent, </span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">   Node[] tab;</span><br><span class="line">   Node p;</span><br><span class="line">   <span class="keyword">int</span> n, i;</span><br><span class="line">   <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">     n = (tab = resize()).length;</span><br><span class="line">   <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">     tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">     …</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>这里n是table数组的长度，hash是key的哈希值经过高16位转低16位的int值。计算节点在table数组的位置的算法是:i = (n - 1) &amp; hash，将数组长度减1后与运算hash。这个算法就很巧妙了，hashmap中数组的长度一定是2的幂，即使初始长度非2的幂也会强制转换为2的幂用hash与(n-1)做位置运算相比%运算更高效，并且这种巧妙的设计也能保证位置i不会超过数组长度。</p><p>当遇到冲突时，正如前面所述，hashmap采用链地址法解决冲突。具体策略如下：</p><p>a) 如果遍历到链表的末尾，说明遍历的过程中未找到key相等的节点，将键值对插入末尾</p><p>b) 如果遍历链表的过程中，存在哈希值一致，引用相等或equals相等的节点，终止遍历，新键值对的值会替换这个节点上原来的值。</p><p>c) 在链表末尾插入新节点后，链表的长度达到8，此时将链表转换为红黑树</p><h4 id="安全加密"><a href="#安全加密" class="headerlink" title="安全加密"></a>安全加密</h4><p>在密码学中，hash算法的作用主要是用于消息摘要和签名，换句话说，它主要用于对整个消息的完整性进行校验。举个例子，我们登陆知乎的时候都需要输入密码，那么知乎如果明文保存这个密码，那么黑客就很容易窃取大家的密码来登陆，特别不安全。那么知乎就想到了一个方法，使用hash算法生成一个密码的签名，知乎后台只保存这个签名值。由于hash算法是不可逆的，那么黑客即便得到这个签名，也丝毫没有用处；而如果你在网站登陆界面上输入你的密码，那么知乎后台就会重新计算一下这个hash值，与网站中储存的原hash值进行比对，如果相同，证明你拥有这个账户的密码，那么就会允许你登陆。银行也是如此，银行是万万不敢保存用户密码的原文的，只会保存密码的hash值而而已。在这些应用场景里，对于抗碰撞和抗篡改能力要求极高，对速度的要求在其次。一个设计良好的hash算法，其抗碰撞能力是很高的。以MD5为例，其输出长度为128位，设计预期碰撞概率为2^128，这是一个极小极小的数字——而即便是在MD5被王小云教授破解之后，其碰撞概率上限也高达，也就是说，至少需要找次才能有1/2的概率来找到一个与目标文件相同的hash值。而对于两个相似的字符串，MD5加密结果如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MD5(&quot;version1&quot;) &#x3D; &quot;966634ebf2fc135707d6753692bf4b1e&quot;;</span><br><span class="line">MD5(&quot;version2&quot;) &#x3D; &quot;2e0e95285f08a07dea17e7ee111b21c8&quot;;</span><br></pre></td></tr></table></figure><p>目前流行的 Hash 算法包括 MD5、SHA-1 和 SHA-2。</p><p>MD4（RFC 1320）是 MIT 的 Ronald L. Rivest 在 1990 年设计的，MD 是 Message Digest 的缩写。其输出为 128 位。MD4 已证明不够安全。</p><p>MD5（RFC 1321）是 Rivest 于1991年对 MD4 的改进版本。它对输入仍以 512 位分组，其输出是 128 位。MD5 比 MD4 复杂，并且计算速度要慢一点，更安全一些。MD5 已被证明不具备”强抗碰撞性”。</p><p>SHA （Secure Hash Algorithm）是一个 Hash 函数族，由 NIST（National Institute of Standards and Technology）于 1993 年发布第一个算法。目前知名的 SHA-1 在 1995 年面世，它的输出为长度 160 位的 hash 值，因此抗穷举性更好。SHA-1 设计时基于和 MD4 相同原理，并且模仿了该算法。SHA-1 已被证明不具”强抗碰撞性”。</p><p>为了提高安全性，NIST 还设计出了 SHA-224、SHA-256、SHA-384，和 SHA-512 算法（统称为 SHA-2），跟 SHA-1 算法原理类似。SHA-3 相关算法也已被提出</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>程序员</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
</search>
